{"success":true,"data":[{"id":"5a9661ff71327bb413bbff5b","author_id":"5110f2bedf9e9fcc584e4677","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://github.com/nswbmw/node-in-debugging/raw/master/assets/book.jpg\" alt>\n《Node.js 调试指南》是本人整理的从事 Node.js 开发这几年的一些调试经验和思路，希望授人以鱼亦能授人以渔。</p>\n<p>享受开源，支持正版~</p>\n<h2>购书链接</h2>\n<ul>\n<li><a href=\"http://product.dangdang.com/25278935.html\">当当</a></li>\n<li><a href=\"https://item.jd.com/12356929.html\">京东</a></li>\n<li><a href=\"https://s.taobao.com/search?q=Node.js%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97\">淘宝</a></li>\n<li><a href=\"https://www.amazon.cn/dp/B07D57FDY4/\">亚马逊</a></li>\n<li><a href=\"http://product.china-pub.com/8004731\">china-pub</a></li>\n</ul>\n<h2>目录</h2>\n<ul>\n<li>CPU 篇\n<ul>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/1.1%20perf%20%2B%20FlameGraph.md\">perf + FlameGraph</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/1.2%20v8-profiler.md\">v8-profiler</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/1.3%20Tick%20Processor.md\">Tick Processor</a></li>\n</ul>\n</li>\n<li>内存篇\n<ul>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/2.1%20gcore%20%2B%20llnode.md\">gcore + llnode</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/2.2%20heapdump.md\">heapdump</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/2.3%20memwatch-next.md\">memwatch-next</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/2.4%20cpu-memory-monitor.md\">cpu-memory-monitor</a></li>\n</ul>\n</li>\n<li>代码篇\n<ul>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/3.1%20Promise.md\">Promise</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/3.2%20Async%20%2B%20Await.md\">Async + Await</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/3.3%20Error%20Stack.md\">Error Stack</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/3.4%20Node%408.md\">Node@8</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/3.5%20Rust%20Addons.md\">Rust Addons</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/3.6%20Event%20Loop.md\">Event Loop</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/3.7%20uncaughtException%20%2B%20llnode.md\">uncaughtException + llnode</a></li>\n</ul>\n</li>\n<li>工具篇\n<ul>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/4.1%20Source%20Map.md\">Source Map</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/4.2%20Chrome%20DevTools.md\">Chrome DevTools</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/4.3%20Visual%20Studio%20Code.md\">Visual Studio Code</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/4.4%20debug%20%2B%20repl2%20%2B%20power-assert.md\">debug + repl2 + power-assert</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/4.5%20supervisor-hot-reload.md\">supervisor-hot-reload</a></li>\n</ul>\n</li>\n<li>APM 篇\n<ul>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/5.1%20NewRelic.md\">NewRelic</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/5.2%20Elastic%20APM.md\">Elastic APM</a></li>\n</ul>\n</li>\n<li>日志篇\n<ul>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/6.1%20koa-await-breakpoint.md\">koa-await-breakpoint</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/6.2%20async_hooks.md\">async_hooks</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/6.3%20ELK.md\">ELK</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/6.4%20OpenTracing%20%2B%20Jaeger.md\">OpenTracing + Jaeger</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/6.5%20Sentry.md\">Sentry</a></li>\n</ul>\n</li>\n<li>监控篇\n<ul>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/7.1%20Telegraf%20%2B%20InfluxDB%20%2B%20Grafana(%E4%B8%8A).md\">Telegraf + InfluxDB + Grafana(上)</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/7.2%20Telegraf%20%2B%20InfluxDB%20%2B%20Grafana(%E4%B8%8B).md\">Telegraf + InfluxDB + Grafana(下)</a></li>\n</ul>\n</li>\n<li>应用篇\n<ul>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/8.1%20node-clinic.md\">node-clinic</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/8.2%20alinode.md\">alinode</a></li>\n</ul>\n</li>\n</ul>\n</div>","title":"《Node.js 调试指南》已出版","last_reply_at":"2018-08-26T11:32:02.049Z","good":true,"top":true,"reply_count":106,"visit_count":23689,"create_at":"2018-02-28T08:02:07.081Z","author":{"loginname":"nswbmw","avatar_url":"https://avatars0.githubusercontent.com/u/4279697?v=4&s=120"}},{"id":"5b223c1d5cd02be640901490","author_id":"515005e9604b3d512109bb17","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FggqZHIE8va72-RguIC8WKGgyzVn\" alt=\"封面\"></p>\n<blockquote>\n<p>千呼万唤始出来，犹抱琵琶生哪吒。</p>\n<p>真的不好意思自卖自夸，所以索性直接把编辑推荐语、大佬们的评语贴上来好了。</p>\n</blockquote>\n<p>Node.js 作为近几年新兴的一种编程运行时，托 V8 引擎的福，在作为后端服务时有比较高的运行效率，在很多场景下对于我们的日常开发足够用了。不过，它还为开发者开了一个使用C++ 开发 Node.js 原生扩展的口子，让开发者进行项目开发时有了更多的选择。</p>\n<p>《Node.js：来一打 C++ 扩展》以 Chrome V8 的知识作为基础，配合 GYP 的一些内容，将教会大家如何使用 Node.js提供的一些 API 来编写其 C++ 的原生扩展。此外，在后续的进阶章节中，还会介绍原生抽象NAN 以及与异步相关的 libuv 知识，最后辅以几个实例来加深理解。不过，在学习本书内容之前，希望读者已经具备了初步的 Node.js 以及 C++ 基础。</p>\n<p>阅读《Node.js：来一打 C++ 扩展》，相当于同时学习Chrome V8 开发、libuv 开发以及 Node.js 的原生 C++ 扩展开发知识，非常值得！</p>\n<p><strong>最后十分感谢包括 Node.js TSC 之一的 Anna、几位 Collaborator 以及各位业界的大佬帮忙写推荐语，感谢 <a href=\"/user/yorkie\">@yorkie</a> 大佬和 <a href=\"/user/justjavac\">@justjavac</a> 大佬帮忙作序。</strong></p>\n<h2>编辑推荐</h2>\n<p>《Node.js：来一打 C++ 扩展》在深度上远远超过了目前市面上的Node书籍。全书自始至终围绕一个主题展开：从介绍 Node.js 的包和模块规范开始，深入解析（包括但不限于剖析 Node.js 自身的源码） Node.js 的模块是如何在运行时被引入的，尤其是如何引入 C++ 模块的；接下来详细讲解了在什么时候、为何要编写 C++ 模块；借此契机，深入介绍了 Node.js 的基石 Chrome V8 和 libuv，以及异步非阻塞的原理——不仅如此，本书更教你如何在底层去驾驭它们。所以，本书以 Node.js 的 C++ 扩展为中心，衍生出对 Node.js 底层风光的层层剖析，最后再回归到如何编写 Node.js 的 C++ 扩展，一气呵成。读来酣畅淋漓，痛快不已！</p>\n<p>买这一本书相当于买了“Node.js 的底层风光、C++ 扩展编写”、“Chrome V8”和“libuv”三本书！</p>\n<p>读完本书后，你甚至能为 Node.js 自身的添砖加瓦做出非凡贡献。</p>\n<h2>购书链接</h2>\n<p><strong>目前在预售阶段，顺便蹭 618 活动。</strong></p>\n<ul>\n<li><a href=\"https://item.jd.com/12380404.html\">京东</a></li>\n<li><a href=\"https://detail.tmall.com/item.htm?id=571628730908&amp;cat_id=2\">天猫</a></li>\n<li><a href=\"http://product.dangdang.com/25291814.html\">当当</a></li>\n<li><a href=\"https://www.amazon.cn/dp/B07DL8GHQC/ie=UTF8&amp;qid=1528969734\">亚马逊</a></li>\n<li><a href=\"http://product.china-pub.com/8039217\">china-pub</a></li>\n<li><a href=\"https://book.douban.com/subject/30247892/\">豆瓣</a>（不算购书链接）</li>\n</ul>\n<h2>目录</h2>\n<pre class=\"prettyprint\"><code>1 Node.js 的 C++ 扩展前驱知识储备 1\n1.1 Node.js 的模块机制 2\n1.1.1 CommonJS 的模块规范 2\n1.1.2 Node.js 的模块 4\n1.1.3 小结 9\n1.1.4 参考资料 9\n1.2 Node.js 的包机制 9\n1.2.1 CommonJS 的包规范 9\n1.2.2 Node.js &#x2F; NPM 下的包 13\n1.2.3 NPM 与 CNPM 16\n1.2.4 小结 19\n1.2.5 参考资料 19\n1.3 Node.js 依赖简介 20\n1.3.1 Chrome V8 20\n1.3.2 libuv 25\n1.3.3 其他依赖 28\n1.3.4 小结 30\n1.3.5 参考资料 30\n1.4 C++ 扩展开发的准备工作 31\n1.4.1 编辑器 &#x2F; IDE 31\n1.4.2 node-gyp 36\n1.4.3 其他构建工具 54\n1.4.4 小结 56\n1.4.5 参考资料 56\n2 C++ 模块原理简析 57\n2.1 为什么要写 C++ 模块 57\n2.1.1 C++ 比 JavaScript 解释器高效 57\n2.1.2 已有的 C++ 轮子 72\n2.1.3 小结 77\n2.1.4 参考资料 77\n2.2 什么是 C++ 扩展 78\n2.2.1 C++ 模块本质 78\n2.2.2 Node.js 模块加载原理 80\n2.2.3 小结 102\n2.2.4 参考资料 103\n3 Chrome V8 基础 104\n3.1 Node.js 与 Chrome V8 104\n3.2 基本概念 105\n3.2.1 内存机制 105\n3.2.2 隔离实例（Isolate） 108\n3.2.3 上下文（Context） 109\n3.2.4 脚本（Script） 110\n3.2.5 小结 110\n3.2.6 参考资料 111\n3.3 句柄（Handle） 111\n3.3.1 本地句柄（Local） 112\n3.3.2 持久句柄（Persistent） 115\n3.3.3 永生句柄（Eternal） 119\n3.3.4 待实本地句柄（Maybe Local） 119\n3.3.5 小结 121\n3.3.6 参考资料 121\n3.4 句柄作用域 121\n3.4.1 一般句柄作用域（Handle Scope） 122\n3.4.2 可逃句柄作用域（Escapable Handle Scope） 125\n3.4.3 小结 129\n3.4.4 参考资料 129\n3.5 上下文（Context） 129\n3.6 模板（Template） 133\n3.6.1 函数模板（Function Template） 133\n3.6.2 对象模板（Object Template） 138\n3.6.3 对象模板的访问器（Accessor）与拦截器（Interceptor） 144\n3.6.4 对象模板的内置字段（Internal Field） 175\n3.6.5 函数模板的继承（Inherit） 183\n3.6.6 小结 188\n3.6.7 参考资料 189\n3.7 常用数据类型 189\n3.7.1 基值（Value） 189\n3.7.2 字符串（String） 194\n3.7.3 数值类型 196\n3.7.4 布尔类型（Boolean） 196\n3.7.5 对象（Object） 196\n3.7.6 函数（Function） 200\n3.7.7 数组（Array） 202\n3.7.8 JSON 解析器 203\n3.7.9 函数回调信息（Function Callback Info） 203\n3.7.10 函数返回值（Return Value） 204\n3.7.11 隔离实例（Isolate） 204\n3.7.12 小结 205\n3.7.13 参考资料 206\n3.8 异常机制 206\n3.8.1 try-catch 206\n3.8.2 抛出异常 209\n3.8.3 异常生成类（Exception） 211\n3.8.4 小结 211\n3.8.5 参考资料 211\n4 C++ 扩展实战初探 212\n4.1 binding.gyp 212\n4.1.1 惊鸿一瞥 213\n4.1.2 binding.gyp 基础结构 213\n4.1.3 GYP 文件 214\n4.1.4 常用字段 221\n4.1.5 小结 228\n4.1.6 参考资料 228\n4.2 牛刀小试 229\n4.2.1 又是 Hello World 229\n4.2.2 函数参数 232\n4.2.3 回调函数 234\n4.2.4 函数返回 238\n4.2.5 小结 239\n4.2.6 参考资料 240\n4.3 循序渐进 240\n4.3.1 C++ 与 JavaScript 类封装 240\n4.3.2 实例化 C++ 类封装对象的函数 250\n4.3.3 将 C++ 类封装对象传来传去 253\n4.3.4 进程退出钩子 255\n4.3.5 小结 259\n4.3.6 参考资料 259\n5 Node.js 原生抽象——NAN 260\n5.1 Node.js 原生模块开发方式的变迁 260\n5.1.1 以不变应万变 260\n5.1.2 时代在召唤 261\n5.1.3 小结 267\n5.1.4 参考资料 267\n5.2 基础开发 267\n5.2.1 什么是 NAN 267\n5.2.2 安装和配置 269\n5.2.3 先睹为快——搭上NAN 的快车 270\n5.2.4 基础帮助函数和宏 276\n5.2.5 忽略 node_modules 279\n5.2.6 小结 279\n5.2.7 参考资料 280\n5.3 JavaScript 函数 280\n5.3.1 函数参数类型 280\n5.3.2 函数声明 282\n5.3.3 函数设置 288\n5.3.4 小结 296\n5.3.5 参考资料 296\n5.4 常用帮助类与函数 296\n5.4.1 句柄相关 296\n5.4.2 创建数据对象 298\n5.4.3 与数据对象“玩耍” 300\n5.4.4 封装一个类 314\n5.4.5 异常处理 315\n5.4.6 小结 315\n5.4.7 参考资料 316\n5.5 NAN 中的异步机制 316\n5.5.1 Nan::AsyncQueueWorker 316\n5.5.2 Nan::Callback 317\n5.5.3 Nan::AsyncWorker 317\n5.5.4 Nan::AsyncProgressWorker 323\n5.5.5 小结 327\n5.5.6 参考资料 327\n6 异步之旅——libuv 328\n6.1 基础概念 329\n6.1.1 事件循环 330\n6.1.2 句柄（Handle）与请求（Request） 333\n6.1.3 尝尝甜头 335\n6.1.4 小结 340\n6.1.5 参考资料 340\n6.2 libuv 的跨线程编程基础 341\n6.2.1 libuv 的线程 342\n6.2.2 同步原语（Synchronization Primitive） 347\n6.2.3 工作队列 355\n6.2.4 小结 356\n6.2.5 参考资料 357\n6.3 跨线程通信 357\n6.3.1 uv_async_t 句柄 357\n6.3.2 Watchdog 半成品实战解析 358\n6.3.3 Watchdog 试运行 367\n6.3.4 小结 368\n6.3.5 参考资料 369\n7 实战——文件监视器 370\n7.1 准备工作 370\n7.1.1 功能规划 370\n7.1.2 文件系统监听库——efsw 373\n7.1.3 小结 376\n7.1.4 参考资料 376\n7.2 核心设计 376\n7.2.1 API 设计 377\n7.2.2 EFSWCore 的血肉之躯 377\n7.2.3 EFSWCore 的灵魂 381\n7.2.4 小结 385\n7.3 编写JavaScript 类 386\n7.3.1 类的设计 386\n7.3.2 核心逻辑 388\n7.3.3 简单容错 391\n7.3.4 小结 393\n7.4 进一步完善 393\n7.4.1 C++ 代码的完善 393\n7.4.2 JavaScript 代码的完善 398\n7.4.3 小结 400\n8 实战——现有包剖析 401\n8.1 字符串哈希模块——Bling Hashes 401\n8.1.1 文件设定 402\n8.1.2 C++ 源码剖析 403\n8.1.3 JavaScript 源码剖析 408\n8.1.4 小结 409\n8.1.5 参考资料 410\n8.2 类 Proxy 包——Auto Object 410\n8.2.1 Proxy 410\n8.2.2 Auto Object 使用范例 412\n8.2.3 代码剖析 415\n8.2.4 小结 424\n8.2.5 参考资料 424\n9 N-API——下一代 Node.js C++ 扩展开发方式 425\n9.1 浅尝辄止 426\n9.1.1 实现一个 Echo 函数 426\n9.1.2 尝试运行 N-API 扩展 430\n9.1.3 向下兼容 431\n9.1.4 N-API Package——C++ 封装 433\n9.1.5 小结 433\n9.1.6 参考资料 433\n9.2 基本数据类型与错误处理 433\n9.2.1 基本数据类型 433\n9.2.2 与作用域及生命周期相关的数据类型 435\n9.2.3 回调数据类型 438\n9.2.4 错误处理 439\n9.2.5 模块注册 441\n9.2.6 小结 442\n9.2.7 参考资料 442\n9.3 对象与函数 442\n9.3.1 对象 442\n9.3.2 函数 448\n9.3.3 类的封装 453\n9.3.4 小结 455\n9.3.5 参考资料 455\n</code></pre><h2>推荐语</h2>\n<blockquote>\n<p>This book contains absolutely everything you need to know about how all the pieces of Node.js’ C++ code work and interact, explaining the necessary concepts without needing prior knowledge about the internals of V8, libuv or other pieces of Node.js. It shows well how Node.js’ own built-in modules are constructed using the APIs provided by V8, so that they are usable from JavaScript, and how you can create the same kind of modules from scratch.</p>\n<p>After having read this book, you will be able to write a production-quality, future-proof C++ extension for Node.js if you need to do that, or maybe even make changes Node.js itself if you’re interested in that!</p>\n<p>这本书包含了所有你需要了解的有关于 Node.js C++ 代码是如何运行和交互的知识，解释了一些你不需要知道 V8 的内部机制就能理解的必要概念，另外该书还介绍了 libuv 以及其他一些内容的方方面面。这本书还展示了 Node.js 的内置模块是如何使用 V8 的 API 进行构建并在 JavaScript 层面能提供使用的——并且你也能用这种方法从头开始创建相同类型的模块。</p>\n<p>读完这本书，你将学到如何写出产品级质量的、面向未来的 Node.js C++ 扩展。感兴趣的话，你甚至可以对 Node.js 自身进行修改！</p>\n<p>——安娜·亨宁森（Anna Henningsen, addaleax），Node.js 技术指导委员会成员（Node.js TSC）</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>Node.js 不是第一个将 JavaScript 带入服务器端领域的技术，然而却成为了史上最热门、最有影响力的工具之一。究其原因，其一，在于 Node.js 适逢后端高并发潮流，巧妙结合 Reactor 模型和 JavaScript 所擅长的回调风格，大大降低了开发高并发服务器应用的成本；其二，在于恰逢浏览器大战，前端技术突飞猛进，急需一个适合 JavaScript 和前端工程师的一套生态和工具链，Node.js 刚好成为前端 JavaScript 最易上手掌握的命令行环境。在 Node.js 发展这么火热之后，Node.js 的开发体验在不断提升，上手门槛也在不断降低。</p>\n<p>然而，如果大家真正想突破自己成为个中高手，无论是后端程序员希望在服务器端及架构方面有所建树，还是前端程序员想跨越边界，你们都应该去了解 Node.js 的底层机制，去学习写一些 Node.js 的扩展。从 Node.js 的内在机制，我们可以学习到更多有关计算机体系的知识如内存管理、多线程编程等等，真正向一个架构师、大牛迈进。</p>\n<p>死月的书，给我们在这些方面带来了一个非常系统的指南。死月通过精彩的内容告诉大家：底层的知识并不枯燥，用 C++ 写一个扩展很有意思也很简单。作为 Node.js 工程师/爱好者的你，值得拥有本书。</p>\n<p>——曹力（ShiningRay），酷链科技 CEO，前暴走漫画 CTO，前糗事百科联合创始人，高级 Node.js 技术专家，《JavaScript 高级程序设计》译者</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>Native module is one of the most underappreciated features of Node.js. But even in the age of asm.js and WebAssembly, it is an irreplaceable part of the Node.js ecosystem due to its versatility and performance. XadillaX’s book provides a refreshing introduction (or reintroduction), and is a must-read for all low-level Node.js engineers.</p>\n<p>原生模块是 Node.js 中最被低估的功能之一。因为它的性能和多样性，使其即使是在 asm.js 和 WebAssembly 时代，仍旧能作为 Node.js 生态系统中不可替代的部分存在。死月的书对其作了一个令人耳目一新的介绍，是所有的底层（Low-Level）Node.js 工程师必读之物。</p>\n<p>——顾天骋（Timothy Gu），pug、ejs 前 Maintainer，Node.js Core Collaborator 之一</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>本书全面讲解了 V8、libuv 的原理并且手把手教你编写一打 Node.js 的 C++ 扩展，是目前市面上相关领域非常空缺的技术书籍。如果想更深入了解 Node.js 的实现原理，除了熟读内置 API 文档之外，阅读这本书会是一个很好的选择。</p>\n<p>——雷宗民（老雷），《Node.js 实战》作者之一</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>这是一本角度刁钻的 Node.js 相关书籍，与市面上大多数的 Node.js 书籍定位不同。它借为 Node.js 开发 C++ 扩展为基石，顺带介绍了 Chrome V8 和 libuv 的内容，填补了市场上这一类书籍的空白，值得一读。</p>\n<p>——李启雷博士，趣链科技 CTO</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>死月一直把实战贯穿在整本书之内，无论是基础部分的 V8 练习，还是使用 Node.js 经典的 Addon 开发、用 NAN 来改写，或是 libuv 里的 WatchDog 案例、EFSW 的封装，甚至在第八章里还特意剖析了两个 C++ 模块，把之前讲解的基础知识部分综合起来，可以边学边练。</p>\n<p>这本《Node.js：来一打 C++ 扩展》，在如今追求大而全的时代，单纯的讲 Node.js 的某一个方面，而且讲的特别棒的书，真的难得。</p>\n<p>——刘琥（响马），西祠胡同创始人，fibjs 作者</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>当你掌握了 Node.js 的上层使用，下一步进阶的方向就是研究 Node.js 的底层原理。本书为学习 Node.js 的实现机制打开了一扇门。书中介绍的上下文（Context）、句柄（Handle）、句柄作用域（Handle Scope）等概念直接来自于源码，对于阅读 Node.js 及 V8 的源码具有极高的参考价值。</p>\n<p>——潘旻琦（pmq20），Node.js 技术专家，Node.js Collaborator 之一，RubyConf 讲师之一</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>国内 Node.js 偏向于原理的书目前只有朴灵的《深入浅出 Node.js》一本，至今 4 年过去了，Node.js 已经从 v0.10 发展到 v9 版本，中间再没有这样的系统的有深度的书籍。</p>\n<p>很高兴死月的新书弥补了这一遗憾。本书以 C++ 为主线，涵盖 Node.js 最核心的 libuv 和 V8，对理解 Node.js 原理有极大的好处。当然最大的好处在于使用 C++ 编写 Node.js Addon 可以让 Node.js 有更广阔的应用空间。我们都知道 Node.js 擅长的是 I/O 密集型任务，对于 CPU 密集型运算这是极好的弥补。</p>\n<p>特别推荐大家阅读此书，Node.js 应用极其广泛的今天，使用 C++ 编写 Node.js Addon 是更出彩的部分，你值得拥有。</p>\n<p>——桑世龙（狼叔），StuQ 明星讲师，Node.js 技术布道者，《更了不起的 Node.js》作者</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>死月对 Node.js 底层机制有非常深入的了解。阅读本书，除了学习 C++ 扩展开发，还会跟随死月了解 V8、libuv，相信读后大家对于 Node.js 的理解会更上一层楼。</p>\n<p>——孙信宇（芋头），大搜车无线架构团队负责人，前端乱炖站长</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>C++ 扩展其实是从外在，用 C++ 的角度去观察 Node.js 内在的形式。因为 Node.js 整个系统自身几乎就是构建在 C/C++ 之上的，只是内部称之为 built-in，在 user-land 则称之 Addon，它们本质上其实没有区别。死月凭借他在 C/C++ 的深厚积累，选择从 C++ 扩展作为突破口，带大家领略 Node.js 底层的风光，在书里，你能看到真正发挥巨大价值的 V8、libuv 亦是精彩纷呈。</p>\n<p>死月将 C++ 扩展写得这么透，我是服的。</p>\n<p>——田永强（朴灵），高级 Node.js 技术专家，《深入浅出 Node.js》作者</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>开发 C++ 扩展，可以扩充 Node.js 平台的本地 API，扩充 Node.js 应用的能力。这本书详细介绍了包括 libuv、V8 在内的各种必要知识，是该领域不可多得的好书。对 C++ 开发者来说，本书既可以作为入门指引，又可以作为日常开发的参考书。</p>\n<p>——王文睿博士（Roger Wang），node-webkit 和 NW.js 项目创始人和维护者，因特尔软件架构师</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>清晰记得手写的第一个 Node.js C++ 扩展模块，在 Node.js 0.6.9 跑通的那种愉悦感。随着应用升级到 Node.js 0.8，依赖的 C++ 扩展模块无法安装编译成功，最后发现是 V8 的 API 变化导致不兼容，从此对 C++ 扩展模块产生抗拒。后来看到《Node.js：来一打 C++ 扩展》，从实现原理，到 V8 基础概念的一系列介绍，让我重新对 C++ 扩展模块产生兴趣。参考书里的实战例子，以及 NAN 的辅助下，现在编写一个跨 Node.js 版本的 C++ 扩展已经不是什么困难的事情。通过最后一章节，可以了解到 Node.js 官方的 N-API 计划，让 C++ 扩展不仅仅能跨版本复用，还能跨操作系统（平台）复用。</p>\n<p>——袁锋（fengmk2），Node.js 技术专家</p>\n</blockquote>\n</div>","title":"《Node.js：来一打 C++ 扩展》已出版，求支持","last_reply_at":"2018-08-23T08:37:23.731Z","good":true,"top":true,"reply_count":100,"visit_count":17597,"create_at":"2018-06-14T09:57:49.652Z","author":{"loginname":"XadillaX","avatar_url":"https://avatars3.githubusercontent.com/u/2842176?v=4&s=120"}},{"id":"5b6913d858db3ccf66a452c9","author_id":"5b691298b71aedfe4c1267e0","tab":"share","content":"<div class=\"markdown-text\"><p>阿里云MVP(Most Valuable Professional，最有价值专家)第六期全球招募开始了! 面向全球开发者，寻找热爱技术、乐于分享的Coder！</p>\n<p><strong>什么是阿里云 MVP？</strong>  阿里云MVP(Most Valuable Professional，最有价值专家)，是专注于帮助他人充分了解和使用阿里云产品和服务的技术实践领袖。截止到2018年6月已经有232位全球各国家和地区的Coder们参加了5期认证。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fp3m6H3ivwP65mX8b1zvzHQZz4Ig\" alt=\"image.png\"></p>\n<p>只要成为MVP，即可享受免费云栖大会门票、最新产品的优先使用权、官方渠道推广等丰厚权益。升级后，还有全球技术留学、高端闭门会议，与顶级技术专家交流学习。与您一同打造《MVP 时间》将您的技术能量传播给更多人，定期邀请阿里技术专家在MVP学院与您共同交流学习提升技术实力。</p>\n<p><img src=\"//dn-cnode.qbox.me/FvNR6aaofpaIpJit_sOxtLMPjgMe\" alt=\"image.png\"></p>\n<p>本期MVP项目与本社区合作推荐技术达人成为侯选人，通过认证您还可以在9月到杭州参与一年一度的MVP高端闭门峰会，第6期认证结果将在9月中旬公布结果。</p>\n<p><strong>什么样的人可以成为阿里云 MVP？</strong>\n你交叉使用过阿里云多款产品；\n你有丰富的技术沉淀、勇于创新、乐于分享；\n你希望能寻找志同道合的资深技术圈，希望建立个人技术影响力。</p>\n<p>你可以马上点击本社区专属申请链接提交申请或扫码填写申请：\n<a href=\"https://mvp.aliyun.com/mvp/apply?recommendType=2&amp;recommendId=LjJNaiBNwbNGUe8RWFb9+A==\">https://mvp.aliyun.com/mvp/apply?recommendType=2&amp;recommendId=LjJNaiBNwbNGUe8RWFb9+A==</a></p>\n<p><img src=\"//dn-cnode.qbox.me/Ft1ylAlk9SWi9QcmyzUo5N2-QHTj\" alt=\"image.png\"></p>\n<p><strong>对于阿里云 MVP申请的一些疑问：</strong></p>\n<p><strong>多久评选一次MVP？</strong>\n每个季度会评选一次，并会在每个季度末宣布MVP入围情况，如果遗憾落选，可在公布名单后，重新到MVP平台提交申请。</p>\n<p><strong>MVP代表阿里云吗？</strong>\n不代表。MVP不是阿里巴巴的员工，他们也不代表阿里云发言。MVP仅是因其在技术社区中的杰出成就，而获得阿里云认可和奖励的第三方个人。</p>\n<p><strong>阿里云MVP大奖的有效期为多长时间？</strong>\nMVP大奖的有效期为一年。在此期间，MVP奖获奖者享有阿里云MVP荣誉称号以及大奖所包括的所有特权。</p>\n</div>","title":"阿里云 MVP第6期招募与社区合作启动","last_reply_at":"2018-08-22T04:06:51.101Z","good":false,"top":true,"reply_count":7,"visit_count":2513,"create_at":"2018-08-07T03:36:56.821Z","author":{"loginname":"bian17888","avatar_url":"https://avatars3.githubusercontent.com/u/3838445?v=4&s=120"}},{"id":"5b5f231f58db3ccf66a45083","author_id":"509ba2ca637ffa41555c0c56","tab":"share","content":"<div class=\"markdown-text\"><p>不仅仅只是 MVC。</p>\n<p>数据复杂，依赖众多，事务密集，业务多变 …</p>\n<p>都说: 一入企业深似海。</p>\n<p>「现象级」的新潮服务端编程语言 Node.js 进入企业级应用开发领域，</p>\n<p>实践与得失值得被分享，讨论，复盘，才会迎来真正的成熟。</p>\n<p>Node.js 地下铁第六期，这个8月，成都，我们和 5 位 Node.js 分享嘉宾，诚邀富有 Node.js 企业级应用开发和架构经验的你一起现场讨论「企业级的 Node.js 实践」。</p>\n<h3>交流会已结束，交流会总结以及分享 slide 下载以及视频请移步 --&gt; <a href=\"https://mp.weixin.qq.com/s?__biz=MzI0MzA3MDQ2OA==&amp;mid=2660173297&amp;idx=1&amp;sn=b1af9764dadd497752d6ce13c7aefe52&amp;chksm=f209069ac57e8f8c869e7e1d7a6ce7931ab859b10b4c54331295ca8c1235a9ee230fceb3f26d&amp;token=207116455&amp;lang=zh_CN#rd\">微信链接</a></h3>\n<h3>时间: 2018. 08. 11</h3>\n<h3>地点: 蚂蚁 C 空间</h3>\n<h3>报名链接: <a href=\"https://survey.alibaba.com/survey/AwDDMHQ-C\">https://survey.alibaba.com/survey/AwDDMHQ-C</a></h3>\n<p>沙龙场地有限，在报名链接中仔细填写「关注企业级的Node.js实践中的哪些具体问题」对最终挑选参加资格会有帮助。</p>\n<h3>Agenda</h3>\n<p><strong>Node.js 微服务架构之路</strong> by 秦粤@阿里巴巴国际</p>\n<blockquote>\n<p>微服务架构组成的要素，如何通过 DDD(Domain Drive Design) 去切分巨石应用；巨石应用平滑演进到微服务；使用 Egg.js + Dubbo 落地 Node.js 的微服务。</p>\n</blockquote>\n<p><strong>企业级的 Node.js 安全保障</strong> by 林晨<a href=\"/user/thoughtworks\">@thoughtworks</a></p>\n<blockquote>\n<p>企业级别的应用需要有企业级别的安全保障，NSP(Node.js Security Platform) 于今年4月被 npm 收购，成为 npm 的重要拼图。分享 NSP 是什么，能解决什么问题，企业如何通过 NSP 来保障应用安全不会被三方依赖的漏洞所影响的最佳实践。</p>\n</blockquote>\n<p><strong>构建一套全栈应用开发模型</strong> by 张挺@淘宝</p>\n<blockquote>\n<p>随着越来越多的 Node.js 应用在阿里体系中萌芽，承载巨大流量的企业级全栈应用也在不断地考验开发者的能力。这些应用的稳定性，扩展性，可维护性，对于前端来说是一个巨大的考验，淘宝在这一方面进行了多年的全栈尝试，这一次，我们在 Midway 框架中，使用了 Typescript 以及依赖注入，给应用带来截然不同的变化。</p>\n</blockquote>\n<p><strong>如何实现一个 Node.js RPC</strong> by 宗羽@蚂蚁金服</p>\n<blockquote>\n<p>Node.js 如何在阿里、蚂蚁这样的公司生存下来？首要解决的是和现有基础设施打通的问题，而 RPC 又是其中最常用的一个基础设施。经过四五年的发展，我们在这块积累了丰富的经验并且经受过多次双 11 级别的考验，可以说已经形成了成熟、可靠、高性能的 Nodejs RPC 方案。我会尝试从零开始介绍一个 RPC 框架的实现原理，包括协议部分、服务寻址、负载均衡等话题。</p>\n</blockquote>\n<p><strong>Stream 企业级实战</strong> by seth@数蚁科技</p>\n<blockquote>\n<p>从基础的 Node.js 处理 stream/buffer 讲起，逐步深入到 Stream 的企业应用实践，比如如何做 part stream，如何做流的限速，如何做的流的加密。</p>\n</blockquote>\n<p><strong>圆桌交流: 企业级的 Node.js 实践</strong></p>\n<p>本次沙龙合作伙伴: ThoughtWorks Community</p>\n</div>","title":"【20180811】Node 地下铁第六期「成都站」线下沙龙邀约 - 企业级的 Node.js 实践","last_reply_at":"2018-08-17T03:01:08.432Z","good":false,"top":true,"reply_count":36,"visit_count":4456,"create_at":"2018-07-30T14:39:27.127Z","author":{"loginname":"wuminqi","avatar_url":"https://avatars1.githubusercontent.com/u/628250?v=4&s=120"}},{"id":"5b82867a944cb8340c27e39a","author_id":"5b8284d3a210553a0cde2c2b","tab":"ask","content":"<div class=\"markdown-text\"><p>我按照官方文档搭建自己的个人网站. 然后也配置好视图这些东西了. 但是一访问就报错.\n<img src=\"//dn-cnode.qbox.me/FuBt4dGIPeQu3JuhzliuxnlpV0E6\" alt=\"image.png\">\n<img src=\"//dn-cnode.qbox.me/FnnvYTY3ErxeXSRGMeOTXAEYwmYr\" alt=\"image.png\">\n<img src=\"//dn-cnode.qbox.me/Fl3ZUXDIAHcvG-EYICjjUxzVuc7J\" alt=\"image.png\">\n<img src=\"//dn-cnode.qbox.me/FhxFa0E0IobVWEqkMYFBy7yT_M8R\" alt=\"image.png\">\n<img src=\"//dn-cnode.qbox.me/FnPXS7pKKf8SIdvC6vC1kQ8Q_dE6\" alt=\"image.png\">\n<img src=\"//dn-cnode.qbox.me/FnHR_OaN9uZuaUhqYqCTjhcYMPZv\" alt=\"image.png\">\n<img src=\"//dn-cnode.qbox.me/FhiCn01d8bkQAjjwKXhzSeiTNE3I\" alt=\"image.png\"></p>\n</div>","title":"小白刚入坑, 遇到一个视图渲染的问题, 恳请各位大佬指点!","last_reply_at":"2018-08-26T16:27:47.451Z","good":false,"top":false,"reply_count":4,"visit_count":89,"create_at":"2018-08-26T10:52:42.456Z","author":{"loginname":"zhangshichuan","avatar_url":"https://avatars2.githubusercontent.com/u/8280832?v=4&s=120"}}]}